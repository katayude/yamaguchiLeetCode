## step1. 自力で解いてみる
思考メモ：
- 下の桁から連結リストで辿れるので、ループで辿ってl1_sumとl2_sumに*10をしつつ加算すればいいかな
- あ、連結リストで返すのか。じゃあ、繰り上がりを持ちながら探索と同時に返すための連結リストも作る必要がある。carry
```python
class Solution:
    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:
        l1_current, l2_current = l1, l2
        carry = 0
        dummy = ListNode()
        current = dummy

        while l1_current or l2_current:
            if not l1_current:
                l1_val = 0
            else:
                l1_val = l1_current.val
            if not l2_current:
                l2_val = 0
            else:
                l2_val = l2_current.val
            if l1_current and l2_current:
                l1_val, l2_val = l1_current.val, l2_current.val        
            sum = l1_val + l2_val + carry
            val = sum % 10
            carry = sum // 10
            new_node = ListNode(val)
            current.next = new_node
            current = current.next
            if l1_current:
                l1_current = l1_current.next
            if l2_current:
                l2_current = l2_current.next

        if carry:
            current.next = ListNode(carry)

        return dummy.next

```
- とりあえず通るコードはかけたけど、条件分岐が汚い。whileの中身が大きくなりすぎている。

## step2 他人のコードを見て修正
- 条件分岐をきれいにする選択肢は、三項演算子とヘルパー関数に切り出す方法があるがどっちを採用しようか。このような軽い処理にヘルパー関数を使うのは常識なのだろうか。当たり前の感覚なのだろうか。
```python
class Solution:
    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:
        def get_val(node):
            if node:
                return node.val
            else:
                return 0

        def get_next(node):
            if node:
                return node.next
            else:
                None

        sentinel = ListNode()
        current = sentinel
        carry = 0

        while l1 or l2 or carry:
            total = get_val(l1) + get_val(l2) + carry
            carry = total // 10
            current.next = ListNode(total % 10)
            current = current.next
            l1 = get_next(l1)
            l2 = get_next(l2)

        return sentinel.next

```
## step3. 時間を測って3回とく
```python
class Solution:
    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:

        def get_val(node):
            if node:
                return node.val
            else:
                return 0

        def get_next(node):
            if node:
                return node.next
            else:
                return None

        sentinel = ListNode()
        current = sentinel
        carry = 0

        while l1 or l2 or carry:
            total = get_val(l1) + get_val(l2) + carry
            carry = total // 10
            current.next = ListNode(total % 10)
            current = current.next
            l1 = get_next(l1)
            l2 = get_next(l2)

        return sentinel.next

```